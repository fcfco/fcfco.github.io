[{"content":"[TOC]\nJDK:开发工具包\nJRE:运行环境\n第三章_流程控制语句 顺序、分支、循环结构\nswitch-case选择结构 语法格式：\n1 2 3 4 5 6 7 8 9 10 11 switch(表达式){ case 常量值1; 语句块1; //break; case 常量值2; 语句块2; //break; //.... default:语句块n+1; break; } 执行流程图：\nfor循环 for (①初始化部分; ②循环条件部分; ④迭代部分)｛\n​ ③循环体部分;\n｝\n**执行过程：**①-②-③-④-②-③-④-②-③-④-\u0026hellip;..-②\n数组 一维数组： 静态初始化（数组变量的初始化和数组元素的赋值操作同时进行）：\n1 2 3 4 int[] arr = new int[]{1,2,3,4,5};//正确 //或 int[] arr; arr = new int[]{1,2,3,4,5};//正确 动态初始化（数组变量的初始化和数组元素的赋值操作分开进行）：\n1 2 3 4 int[] arr = new int[5]; //或 int[] arr; arr = new int[5]; 数组长度：arr.length\n数组的下标从[0]开始，下标范围是[0, arr.length-1]\n一维数组遍历：\n1 2 3 for(int i=0; i\u0026lt;arr.length; i++){ System.out.println(arr[i]); } 一维数组内存图\n1 2 3 4 public static void main(String[] args) { int[] arr = new int[3]; System.out.println(arr);//[I@5f150435 } 二维数组： 静态初始化：\n1 2 3 4 5 int[][] arr = new int[][]{{3,8,2},{2,7},{9,0,1,6}}; //或 int[][] arr; arr = new int[][]{{1,2,3},{4,5,6},{7,8,9,10}}; 注意特殊写法情况：int[] x,y[]; x 是一维数组，y 是二维数组。 动态初始化：\n1 2 3 4 格式 1：规则二维表：每一行的列数是相同的 int[][] arr = new int[3][2]; 格式 2：不规则：每一行的列数不一样 int[][] arr = new int[3][]; 某一行的列数：二维数组名[行下标].length\n1 2 二维数组的长度/行数：二维数组名.length 某一行的列数：二维数组名[行下标].length 二维数组的遍历\n1 2 3 4 5 for(int i=0; i\u0026lt;arr.length; i++){ //二维数组对象.length for(int j=0; j\u0026lt;arr[i].length; j++){//二维数组行对象.length System.out.print(arr[i][j]); } } 内存图\n数组复制 数组的反转 1 2 3 4 5 6 for(int i = 0,j = arr.length - 1;i \u0026lt; j;i++,j--){ //交互arr[i] 与 arr[j]位置的元素 int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } 数组的扩容和缩容 1 2 3 4 5 6 7 8 //扩容1倍容量 int[] newArr = new int[arr.length * 2]; //或 int[] newArr = new int[arr.length \u0026lt;\u0026lt; 1]; //缩容1倍容量 int[] newArr = new int[arr.length / 2]; //或 int[] newArr = new int[arr.length \u0026gt;\u0026gt; 1]; 数组元素查找 顺序查找\n二分查找\n1 2 3 4 5 6 7 8 9 10 11 12 13 int head = 0;//默认的首索引 int end = arr2.length - 1;//默认的尾索引 while(head \u0026lt;= end){ int middle = (head + end) / 2; if(target == arr2[middle]){ System.out.println(\u0026#34;找到了\u0026#34; + target + \u0026#34;,对应的位置为：\u0026#34; + middle); break; }else if(target \u0026gt; arr2[middle]){ head = middle + 1; }else{//target \u0026lt; arr2[middle] end = middle - 1; } } 数组排序算法 冒泡排序： 思想：\n1.比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。\n2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n3.针对所有的元素重复以上的步骤，除了最后一个。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 int[] arr = {1, 3, 5, 7, 9}; //目标：从小到大 //冒泡排序的轮数 = 元素的总个数 - 1 //轮数是多轮，每一轮比较的次数是多次，需要用到双重循环，即循环嵌套 //外循环控制 轮数，内循环控制每一轮的比较次数和过程 /* 假设 arr.length=5 i=1,第 1 轮，比较 4 次 arr[0]与 arr[1] arr[1]与 arr[2] arr[2]与 arr[3] arr[3]与 arr[4] arr[j]与 arr[j+1]，int j=0;j\u0026lt;4; j++ i=2,第 2 轮，比较 3 次 arr[0]与 arr[1] arr[1]与 arr[2] arr[2]与 arr[3] arr[j]与 arr[j+1]，int j=0;j\u0026lt;3; j++ i=3,第 3 轮，比较 2 次 arr[0]与 arr[1] arr[1]与 arr[2] arr[j]与 arr[j+1]，int j=0;j\u0026lt;2; j++ i=4,第 4 轮，比较 1 次 arr[0]与 arr[1] arr[j]与 arr[j+1]，int j=0;j\u0026lt;1; j++ int j=0; j\u0026lt;arr.length-i; j++ */ for (int i = 0; i \u0026lt; arr.length - 1; i++) { for (int j = 0; j \u0026lt; arr.length - 1 - i; j++) { //希望的是 arr[j] \u0026lt; arr[j+1] if (arr[j] \u0026gt; arr[j + 1]) { //交换 arr[j]与 arr[j+1] int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } 快速排序\n思想：\n1.从数列中挑出一个元素，称为\u0026quot;基准\u0026quot;（pivot），\n2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区操作。\n3.递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。\n4.递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代中，它至少会把一个元素摆到它最后的位置去。\n数组工具类 二分查找：Arrays.binarySearch 重写：Arrays.toString 判断相等：Arrays.equals 填充：Arrays.fill\n数组异常 数组角标越界的异常：ArrayIndexOutOfBoundsException 空指针的异常：NullPointerException\n面向对象 学习面向对象内容的三条主线\nJava 类及类的成员：（重点）属性、方法、构造器；（熟悉）代码块、内部类\n面向对象的3大特征：封装、继承、多态（抽象）\n其他关键字的使用：this、super、package、import、static、final、interface、abstract 等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 例子：人把大象装进冰箱 面向过程： 1.打开冰箱 2.把大象装进冰箱 3.把冰箱门关住 面向对象： 人{ 打开（冰箱）{ 冰箱.开门(); } 操作(大象){ 大象.进入(冰箱); } 关闭(冰箱){ 冰箱.关门(); } } 冰箱{ 开门(){ } 关门(){ } } 大象{ 进入(冰箱){ } } 类：具有相同特征的事物的抽象描述，是抽象的、概念上的定义。\n对象：实际存在的该类事物的每个个体，是具体的，因而也称为实例\n面向对象3步骤 1.类定义\n1 2 3 4 5 6 7 8 public class Person{ //声明属性 age int age ; //声明方法 showAge() public void eat() { System.out.println(\u0026#34;人吃饭\u0026#34;); } } 2.对象的创建\n1 2 3 4 5 6 7 8 class PersonTest{ public static void main(String[] args){ //创建 Person 类的对象 Person per = new Person(); //创建 Dog 类的对象 Dog dog = new Dog(); } } 3.对象调用属性或方法\n对象名.属性或对象名.方法\n匿名对象 new Person().shout();\n如果一个对象只需要进行一次方法调用，那么就可以使用匿名对象\n对象内存解析 **堆：**凡是 new 出来的结构(对象、数组)都放在堆空间中。\n对象名中存储的是对象地址\n成员变量 1 2 3 4 public class Person{ private int age; //声明 private 变量 age public String name = “Lila”; //声明 public 变量 name } 在方法体外，类体内声明的变量称为成员变量。\n在方法体内部等位置声明的变量称为局部变量。\n方法 方法是类或对象行为特征的抽象，用来完成某个功能操作\n将功能封装为方法的目的是，可以实现代码重用，减少冗余，简化代码\n1 2 3 4 5 6 7 8 9 public class Person{ private int age; public int getAge() { //声明方法 getAge() return age; } public void setAge(int i) { //声明方法 setAge age = i; //将参数 i 的值赋给类的成员变量 age } } 声明方法 无返回值，则声明：void 默认跟sout搭配使用\n有返回值，则声明出返回值类型（可以是任意类型）。与方法体中“return 返回值搭配使用\n形参列表：表示完成方法体功能时需要外部提供的数据列表。可以包含零个，一个或多个\n参数。如果有参数，每一个参数都要指定数据类型和参数名，多个参数之间使用逗号分隔\n1个参数： (数据类型 参数名)\n2个参数： (数据类型 1 参数 1, 数据类型 2 参数 2)\n参数的类型可以是基本数据类型、引用数据类型\n1 2 3 public int max(int a, int b){ return a \u0026gt; b ? a : b; } 调用实例方法 对象.方法名([实参列表])\n方法使用注意 方法必须定义在类的内部\n1 2 3 4 5 6 类{ 方法 1(){ } 方法 2(){ } } 方法调用内存分析 方法被调用的时候，需要进入到栈内存中运行。方法每调用一次就会在栈中有一个入栈动作\n当方法执行结束后，会释放该内存，称为出栈\n栈结构：先进后出，后进先出\n对象数组 数组的元素可以是基本数据类型，也可以是引用数据类型。当数组元素是引用类型中的类时，我们称为对象数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 定义类 Student，包含三个属性：学号 number(int)，年级 state(int)，成绩score(int)。 创建 20 个学生对象，学号为 1 到 20，年级和成绩都由随机数确定。 问题一：打印出 3 年级(state 值为 3）的学生信息。 问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息 public class StudentTest { public static void main(String[] args) { //创建Student[] Student[] students = new Student[20]; //String[] strs = new String[20]; //使用循环，给数组的元素赋值 for (int i = 0; i \u0026lt; students.length; i++) { students[i] = new Student(); //给每一个学生对象的number、state、score属性赋值 students[i].number = i + 1; students[i].state = (int)(Math.random() * 6 + 1); students[i].score = (int)(Math.random() * 101); } //需求1：打印出3年级(state值为3）的学生信息 for (int i = 0; i \u0026lt; students.length; i++) { if(3 == students[i].state){ Student stu = students[i]; System.out.println(stu.show()); } } //需求2：使用冒泡排序按学生成绩排序，并遍历所有学生信息 //排序前遍历 for (int i = 0; i \u0026lt; students.length; i++) { System.out.println(students[i].show()); } System.out.println(\u0026#34;********************\u0026#34;); for (int i = 0; i \u0026lt; students.length; i++) { for (int j = 0; j \u0026lt; students.length - 1 - i; j++) { if(students[j].score \u0026gt; students[j + 1].score){ //正确的 Student temp = students[j]; students[j] = students[j + 1]; students[j + 1] = temp; } } } } } 对象数组，首先要创建数组对象本身，即确定数组的长度，然后再创建每一个元素对象，如果不创建，数组的元素的默认值就是 null，所以很容易出现空指针异常NullPointerException\n方法重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 两同：同一个类、相同的方法名 一不同：参数列表不同。① 参数个数不同 ② 参数类型不同（顺序不同也算） 注意：方法的重载与形参的名、权限修饰符、返回值类型都没有关系。 例1： //返回两个整数的和 public int add(int x,int y){ return x+y; } //返回三个整数的和 public int add(int x,int y,int z){ return x+y+z; } //返回两个小数的和 public double add(double x,double y){ return x+y; } 例2： public class MathTools { //以下方法不是重载，会报错 方法的重载和返回值类型无关 public int getOneToHundred(){ return (int)(Math.random()*100); } public double getOneToHundred(){ return Math.random()*100; } } 可变形参 方法名(参数的类型名 \u0026hellip;参数名)\n1 public static void test(int a,String...books); 可变参数：方法参数部分指定类型的参数个数是可变多个：0 个，1 个或多个\n方法的参数部分有可变形参，需要放在形参声明的最后\n在一个方法的形参中，最多只能声明一个可变个数的形参\n方法参数传递机制 Java 里方法的参数传递方式只有一种：值传递。\n形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参\n形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参\n形参是基本数据类型\n形参是引用数据类型\n递归 递归方法调用：方法自己调用自己的现象就称为递归。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 直接递归：方法自身调用自己。 public void methodA(){ methodA(); } 间接递归：可以理解为 A()方法调用 B()方法，B()方法调用 C()方法，C()方法调用 A()方法。 public static void A(){ B(); } public static void B(){ C(); } public static void C(){ A(); } 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 举例 3：已知有一个数列：f(0) = 1，f(1) = 4，f(n+2)=2*f(n+1) + f(n)，其中n是大于0的整数，求f(10)的值。 public int f(int num){ if(num == 0){ return 1; }else if(num == 1){ return 4; }else{ return 2 * f(num - 1) + f(num - 2); } } 举例 4：已知一个数列：f(20) = 1,f(21) = 4,f(n+2) = 2*f(n+1)+f(n)，其中 n 是大于 0 的整数，求 f(10)的值。 public int func(int num){ if(num == 20){ return 1; }else if(num == 21){ return 4; }else{ return func(num + 2) - 2 * func(num + 1); } } 关键字 package，称为包，用于指明该文件中定义的类、接口等结构所在的包。\npackage pack1.pack2\n面向对象特征一：封装性(encapsulation) 面向对象的开发原则要遵循“高内聚、低耦合”\n高内聚：类的内部数据操作细节自己完成，不允许外部干涉。\n低耦合：仅暴露少量的方法给外部使用，尽量方便外部调用\n封装概念：把该隐藏的隐藏起来，该暴露的暴露出来。\n实现封装就是控制类或成员的可见性范围。这就需要依赖访问控制修饰符，也称为权\n限修饰符来控制。\n具体修饰的结构：\n外部类：public、缺省\n成员变量、成员方法、构造器、成员内部类：public、protected、缺省、\nprivate\n成员变量/属性私有化 概述：私有化类的成员变量，提供公共的 get 和 set 方法，对外暴露获取和修改属性的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ① 使用 private 修饰成员变量 private 数据类型 变量名 ； 代码如下： public class Person { private String name; } ② 提供 getXxx 方法 / setXxx 方法，可以访问成员变量，代码如下： public class Person { private String name; public void setName(String n) { name = n; } public String getName() { return name; } } ③ 测试： public class PersonTest { public static void main(String[] args) { Person p = new Person(); //实例变量私有化，跨类是无法直接使用的 /* p.name = \u0026#34;张三\u0026#34;;*/ p.setName(\u0026#34;张三\u0026#34;); System.out.println(\u0026#34;p.name = \u0026#34; + p.getName()); } 注意：开发中，一般成员实例变量都习惯使用 private 修饰，再提供相应的public权限的 get/set 方法访问。 类的成员之三：构造器(Constructor) 构造器（Constructor)，也称为构造方法\n构造器的作用 new 对象，并在 new 对象的时候为实例变量赋值。举例：Person p = new Person(“Peter”,15);\n构造器语法格式 [修饰符] class 类名{\n[修饰符] 构造器名(){\n// 实例初始化代码\n}\n[修饰符] 构造器名(参数列表){\n// 实例初始化代码\n}\n}\n说明：\n构造器名必须与它所在的类名必须相同。\n它没有返回值，所以不需要返回值类型，也不需要 void。\n构造器的修饰符只能是权限修饰符，不能被其他任何修饰。比如，不能被 static、final、synchronized、abstract、native 修饰，不能有 return 语句返回值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Student { private String name; private int age; // 无参构造 public Student() {} // 有参构造 public Student(String n,int a) { name = n; age = a; } public String getName() { return name; } public void setName(String n) { name = n; } public int getAge() { return age; } public void setAge(int a) { age = a; } public String getInfo(){ return \u0026#34;姓名：\u0026#34; + name +\u0026#34;，年龄：\u0026#34; + age; } } public class TestStudent { public static void main(String[] args) { //调用无参构造创建学生对象 Student s1 = new Student(); //调用有参构造创建学生对象 Student s2 = new Student(\u0026#34;张三\u0026#34;,23); System.out.println(s1.getInfo()); System.out.println(s2.getInfo()); } } 当我没有声明类中的构造器时，系统会默认提供一个无参的构造器并且该构造器的修饰符默认与类的修饰符相同\n当我们定义类的构造器以后，系统就不再提供默认的无参的构造器了。\n在类中，至少会存在一个构造器。\n类中属性赋值过程 在类的属性中，这些位置给属性赋值\n① 默认初始化\n② 显式初始化\n③ 构造器中初始化\n④ 通过\u0026quot;对象.属性\u0026quot;或\u0026quot;对象.方法\u0026quot;的方式，给属性赋值\n2、这些位置执行顺序\n顺序：① - ② - ③ - ④\n上述中的①、②、③在对象创建过程中，只执行一次。\n④ 是在对象创建后执行的，可以根据需求多次执行\nJavaBean JavaBean 是一种 Java 语言写成的可重用组件。\n好比你做了一个扳手，这个扳手会在很多地方被拿去用。这个扳手也提供\n多种功能(你可以拿这个扳手扳、锤、撬等等)，而这个扳手就是一个组件。\n所谓 JavaBean，是指符合如下标准的 Java 类：\n类是公共的 有一个无参的公共的构造器 有属性，且有对应的 get、set 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class JavaBean { private String name; // 属性一般定义为 private private int age; public JavaBean() { } public int getAge() { return age; } public void setAge(int a) { age = a; } public String getName() { return name; } public void setName(String n) { name = n; } } UML类图 +表示 public 类型， - 表示 private 类型，#表示 protected 类型\n方法的写法: 方法的类型(+、-) 方法名(参数名： 参数类型)：返回值类型\n斜体表示抽象方法或类\n面向对象编程（进阶） 1.关键字：this 方法内部使用，表示调用该方法的对象\n构造器内部使用，表示该构造器正在初始化的对象。\n1 2 3 public void setName(String name){ //当属性名和形参名同名时，必须使用this来区分 this.name = name; } this 可以调用的结构：成员变量、方法和构造器\n1.2.1实例方法或构造器中使用当前对象的成员 用 this 来区分成员变量和局部变量\n使用 this 访问属性和方法时，如果在本类中未找到，会从父类中查找。\n1.2.2同一个类中构造器互相调用 this 可以作为一个类中构造器相互调用的特殊格式。\nthis()：调用本类的无参构造器\nthis(实参列表)：调用本类的有参构造器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Student { private String name; private int age; // 无参构造 public Student() { // this(\u0026#34;\u0026#34;,18);//调用本类有参构造器 } // 有参构造 public Student(String name) { this();//调用本类无参构造器 this.name = name; } // 有参构造 public Student(String name,int age){ this(name);//调用本类中有一个 String 参数的构造器 this.age = age; .......略 } } 注意：this()和 this(实参列表)只能声明在构造器首行。\n推论：在类的一个构造器中，最多只能声明一个\u0026quot;this(参数列表)\u0026quot;\n客户管理系统 1 2 3 4 5 6 7 8 9 10 11 public boolean deleteCustomer(int index) { if (index \u0026lt; 0 || index \u0026gt;= total) return false; for (int i = index; i \u0026lt; total - 1; i++) { customers[i] = customers[i + 1]; } customers[--total] = null; return true; } 2.面向对象特征二：继承(Inheritance) 继承后如图：\n说明：Student 类继承了父类 Person 的所有属性和方法，并增加了一个属性 school。Person 中的属性和方法，Student 都可以使用。\n2.1继承性的好处 减少了代码的冗余，提高了复用性； 提高了扩展性 为多态的使用，提供了前提。 2.2继承语法 通过 extends 关键字，可以声明一个类 B 继承另外一个类 A，定义格式如下：\n1 2 3 4 5 6 [修饰符] class 类 A { ... } [修饰符] class 类 B extends 类 A { ... } 类 B，称为子类 类 A，称为父类\n2.3继承性的细节说明 1、子类会继承父类所有的实例变量和实例方法\n2、子类不能直接访问父类中私有的(private)的成员变量和方法\n3、继承的关键字使用“extends”，是对父类的“扩展”\n4、Java 支持多层继承(继承体系)\n1 2 3 classA{} class B extends A{} class C extends B{} 5、一个父类可以同时拥有多个子类\n1 2 3 4 class A{} class B extends A{} class D extends A{} class E extends A{} 6、Java 只支持单继承，不支持多重继承\n3.方法的重写（override/overwrite） 子类对父类中继承过来的方法进行覆盖、覆写的操作\n在程序执行时，子类的方法将覆盖父类的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Phone { public void call(){ System.out.println(\u0026#34;打电话\u0026#34;); } } public class SmartPhone extends Phone{ //重写父类的来电显示功能的方法 @Override //重写父类的通话功能的方法 @Override public void call() { System.out.println(\u0026#34;语音通话 或 视频通话\u0026#34;); } } @Override 使用说明：写在方法上面，用来检测是否满足重写方法的要求。\n3.1要求 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表。\n子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型。（例如：Student \u0026lt; Person）。\n注意：如果返回值类型是基本数据类型和 void，那么必须是相同\n子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限。（public \u0026gt; protected \u0026gt; 缺省 \u0026gt; private）\n注意：① 父类私有方法不能重写 ② 跨包的父类缺省的方法也不能重写\n子类方法抛出的异常不能大于父类被重写方法的异常\n子类与父类中同名同参数的方法必须同时声明为非 static 的(即为重写)，或者同时声明为 static 的（不是重写）。因为 static 方法是属于类的，子类无法覆盖父类的方法。\n3.2方法的重载与重写 方法的重载：“两同一不同” 方法的重写： 前提：类的继承关系 子类对父类中同名同参数方法的覆盖、覆写。 5.关键字：super 在 Java 类中使用 super 来调用父类中的指定操作：\n访问父类中定义的属性 调用父类中定义的成员方法 在子类构造器中调用父类的构造器 5.2super 的使用场景 5.2.1子类中调用父类被重写的方法 如果子类没有重写父类的方法，只要权限修饰符允许，在子类中完全可以直接调用父类的方法； 如果子类重写了父类的方法，在子类中需要通过 *super.*才能调用父类被重写的方法，否则默认调用的子类重写的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Phone { public void showNum(){ System.out.println(\u0026#34;来电显示号码\u0026#34;); } public class SmartPhone extends Phone{ //重写父类的来电显示功能的方法 public void showNum(){ System.out.println(\u0026#34;显示来电姓名\u0026#34;); System.out.println(\u0026#34;显示头像\u0026#34;); //保留父类来电显示号码的功能 super.showNum();//此处必须加 super.，否则就是无限递归，那么就会栈 内存溢出 } } **方法前面没有 super.和 this.**先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上找 **方法前面有 this.**先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上找 **方法前面有 super.**从当前子类的直接父类找，如果没有，继续往上找 5.2.2 子类中调用父类中同名的成员变量 如果实例变量与局部变量重名，可以在实例变量前面加 this.进行区别 如果子类实例变量和父类实例变量重名，并且父类的该实例变量在子类仍然可见，在子类中要访问父类声明的实例变量需要在父类实例变量前加 super.，否则默认访问的是子类自己声明的实例变量 如果父子类实例变量没有重名，只要权限修饰符允许，在子类中完全可以直接访问父类中声明的实例变量，也可以用 this.实例访问，也可以用 super.实例变量访问 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Father{ int a = 10; int b = 11; } class Son extends Father{ int a = 20; public void test(){ //子类与父类的属性同名，子类对象中就有两个 a System.out.println(\u0026#34;子类的 a：\u0026#34; + a);//20 先找局部变量找，没有再 从本类成员变量找 System.out.println(\u0026#34;子类的 a：\u0026#34; + this.a);//20 先从本类成员变 量找 System.out.println(\u0026#34;父类的 a：\u0026#34; + super.a);//10 直接从父类成 员变量找 //子类与父类的属性不同名，是同一个 b System.out.println(\u0026#34;b = \u0026#34; + b);//11 先找局部变量找，没有再从本 类成员变量找，没有再从父类找 System.out.println(\u0026#34;b = \u0026#34; + this.b);//11 先从本类成员变量找， 没有再从父类找 System.out.println(\u0026#34;b = \u0026#34; + super.b);//11 直接从父类局部变量找 } public void method(int a, int b){ //子类与父类的属性同名，子类对象中就有两个成员变量 a，此时方法中还有 一个局部变量 a System.out.println(\u0026#34;局部变量的 a：\u0026#34; + a);//30 先找局部变量 System.out.println(\u0026#34;子类的 a：\u0026#34; + this.a);//20 先从本类成员变量 找 System.out.println(\u0026#34;父类的 a：\u0026#34; + super.a);//10 直接从父类成员 变量找 System.out.println(\u0026#34;b = \u0026#34; + b);//13 先找局部变量 System.out.println(\u0026#34;b = \u0026#34; + this.b);//11 先从本类成员变量找 System.out.println(\u0026#34;b = \u0026#34; + super.b);//11 直接从父类局部变量找 } } class Test{ public static void main(String[] args){ Son son = new Son(); son.test(); son.method(30,13); } } 总结：起点不同（就近原则）\n变量前面没有 super.和 this.\n在构造器、代码块、方法中如果出现使用某个变量，先查看是否是当前块声明的局部变量， 如果不是局部变量，先从当前执行代码的本类去找成员变量 如果从当前执行代码的本类中没有找到，会往上找父类声明的成员变量（权限修饰符允许在子类中访问的） 变量前面有 this.\n通过 this 找成员变量时，先从当前执行代码的==本类去找成员变量== 如果从当前执行代码的本类中没有找到，会往上找==父类声明的成员变量（==权限修饰符允许在子类中访问的） 变量前面 super.–\n通过 super 找成员变量，直接从当前执行代码的直接父类去找成员变量（权限修饰符允许在子类中访问的） 如果直接父类没有，就去父类的父类中找（权限修饰符允许在子类中访问的） 5.2.3子类构造器中调用父类构造器 ① 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器。 ② 规定：“super(形参列表)”，必须声明在构造器的首行。③ 我们前面讲过，在构造器首行可以使用\u0026quot;this(形参列表)\u0026quot;，调用本类中重载的构造器， 结合②，结论：在构造器的首行，\u0026ldquo;this(形参列表)\u0026rdquo; 和 \u0026ldquo;super(形参列表)\u0026ldquo;只能二选一。 ④ 如果在子类构造器的首行既没有显示调用\u0026quot;this(形参列表)\u0026quot;，也没有显式调用\u0026quot;super(形参列表)\u0026quot;， 则子类此构造器默认调用\u0026quot;super()\u0026quot;，即调用父类中空参的构造器。 ⑤ 由③和④得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。 只能是这两种情况之一。 ⑥ 由⑤得到：一个类中声明有 n 个构造器，最多有 n-1 个构造器中使用了\u0026quot;this(形参列表)\u0026quot;，则剩下的那个一定使用\u0026quot;super(形参列表)\u0026quot;。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class A{ A(){ System.out.println(\u0026#34;A 类无参构造器\u0026#34;); } } class B extends A{ B(){ System.out.println(\u0026#34;B 类无参构造器\u0026#34;); } } class Test{ public static void main(String[] args){ B b = new B(); //A 类显示声明一个无参构造， //B 类显示声明一个无参构造， //B 类的无参构造中虽然没有写 super()，但是仍然会默认调用 A 类的无参 构造 //可以看到会输出“A 类无参构造器\u0026#34;和\u0026#34;B 类无参构造器\u0026#34;) 5.3 this与super 1、this 和 super 的意义\nthis：当前对象\n在构造器和非静态代码块中，表示正在 new 的对象 在实例方法中，表示调用当前方法的对象 super：引用父类声明的成员\n2、this 和 super 的使用格式\nthis\nthis.成员变量：表示当前对象的某个成员变量，而不是局部变量 this.成员方法：表示当前对象的某个成员方法，完全可以省略 this. this()或 this(实参列表)：调用另一个构造器协助当前对象的实例化，只能在构造器首行，只会找本类的构造器，找不到就报错 super\nsuper.成员变量：表示当前对象的某个成员变量，该成员变量在父类中声明的 super.成员方法：表示当前对象的某个成员方法，该成员方法在父类中声明的 super()或 super(实参列表)：调用父类的构造器协助当前对象的实例化，只能在构造器首行，只会找直接父类的对应构造器，找不到就报错 6.（熟悉）子类对象实例化的全过程 结果上来说：体现为继承性 过程上来说：子类调用构造器创建对象时，一定会直接或间接的调用其父类的构造器，以及父类的父类的构造器，\u0026hellip;，直到调用到Object()的构造器。 7.面向对象的特征三：多态性 7.1多态的形式和体现 7.1.1 对象的多态性 对象的多态性：父类的引用指向子类的对象\nObject obj = new String(\u0026quot;hello\u0026quot;); 对象的多态：在 Java 中，子类的对象可以替代父类的对象使用。所以，一个引\n用类型变量可能指向(引用)多种不同类型的对象\n7.1.2多态的理解 编译时，看左边；运行时，看右边。\n若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism) 多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的方法） “看右边”：看的是子类的对象（实际运行的是子类重写父类的方法） 多态的使用前提：① 类的继承关系 ② 方法的重写\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class TestPerson { public static void main(String[] args) { Person person = new Person(); Dog dog = new Dog(); dog.setNickname(\u0026#34;小白\u0026#34;); person.adopt(dog);//实参是 dog 子类对象，形参是父类 Pet 类型 person.feed(); Cat cat = new Cat(); cat.setNickname(\u0026#34;雪球\u0026#34;); person.adopt(cat);//实参是 cat 子类对象，形参是父类 Pet 类型 person.feed(); } } 7.3 多态的好处和弊端 好处：变量引用的子类对象不同，执行的方法就不同，实现动态绑定。代码编写更灵活、功能更强大，可维护性和扩展性更好了。减少了大量的重载的方法的定义；开闭原则(对扩展开放，对修改关闭)\n弊端：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。\n7.4虚方法调用 编译看左边，运行看右边\n7.5成员变量没有多态性 属性，不存在多态性\n7.6向上转型与向下转型 向下转型：当左边的变量的类型（子类）\u0026lt;右边对象/变量的编译时类型（父类）\n7.6.2如何向上或向下转型 向上转型：自动完成\n向下转型：（子类类型）父类变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class ClassCastTest { public static void main(String[] args) { //没有类型转换 Dog dog = new Dog();//dog 的编译时类型和运行时类型都是 Dog //向上转型 Pet pet = new Dog();//pet 的编译时类型是 Pet，运行时类型是 Dog pet.setNickname(\u0026#34;小白\u0026#34;); pet.eat();//可以调用父类 Pet 有声明的方法 eat，但执行的是子类重写的eat 方法体 // pet.watchHouse();//不能调用父类没有的方法 watchHouse Dog d = (Dog) pet; System.out.println(\u0026#34;d.nickname = \u0026#34; + d.getNickname()); d.eat();//可以调用 eat 方法 d.watchHouse();//可以调用子类扩展的方法 watchHouse Cat c = (Cat) pet;//编译通过，因为从语法检查来说，pet 的编译时类型是 Pet，Cat 是 Pet 的子类，所以向下转型语法正确 //这句代码运行报错 ClassCastException，因为 pet 变量的运行时类型是 Dog，Dog 和 Cat 之间是没有继承关系的 } } 7.6.3 instanceof 关键字 为了避免 ClassCastException（异常） 的发生，Java 提供了 instanceof 关键字，给引\n用变量做类型的校验。如下代码格式：\n*//*检验对象 a 是否是数据类型 A 的对象，返回值为 boolean 型\n对象 a instanceof 数据类型 A\n要求对象 a 所属的类与类 A 必须是子类和父类的关系，否则编译错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class TestInstanceof { public static void main(String[] args) { Pet[] pets = new Pet[2]; pets[0] = new Dog();//多态引用 pets[0].setNickname(\u0026#34;小白\u0026#34;); pets[1] = new Cat();//多态引用 pets[1].setNickname(\u0026#34;雪球\u0026#34;); for (int i = 0; i \u0026lt; pets.length; i++) { pets[i].eat(); if(pets[i] instanceof Dog){ Dog dog = (Dog) pets[i]; dog.watchHouse(); }else if(pets[i] instanceof Cat){ Cat cat = (Cat) pets[i]; cat.catchMouse(); } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class InterviewTest2 { public static void main(String[] args) { Father f = new Father(); Son s = new Son(); System.out.println(f.getInfo());//atguigu System.out.println(s.getInfo());//尚硅谷 s.test();//尚硅谷 atguigu System.out.println(\u0026#34;-----------------\u0026#34;); s.setInfo(\u0026#34;大硅谷\u0026#34;); System.out.println(f.getInfo());//atguigu System.out.println(s.getInfo());//大硅谷 s.test();//大硅谷 atguigu } } class Father { private String info = \u0026#34;atguigu\u0026#34;; public void setInfo(String info) { this.info = info; } public String getInfo() { return info; } } class Son extends Father { private String info = \u0026#34;尚硅谷\u0026#34;; public void setInfo(String info) { this.info = info; } public String getInfo() { return info; } public void test() { System.out.println(this.getInfo()); System.out.println(super.getInfo()); } } 8.Object类的使用 所有其它类的父类。每个类都使用 Object 作为超类\n8.1equals() ==\n1 2 3 //基本类型比较值:只要两个变量的值相等，即为 true。 int a=5; if(a==6){…} 1 2 3 4 //引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才返回 true。 Person p1=new Person(); Person p2=new Person(); if (p1==p2){…} equals():所有类都继承了 Object，也就获得了 equals()方法。还可以重写。\n只能比较引用类型，Object 类源码中 equals()的作用与“==”相同：比较是否指向同一个对象。 格式:obj1.equals(obj2) 特例：当用 equals()方法进行比较时，对类 File、String、Date 及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象； 当自定义使用 equals()时，可以重写。用于比较两个对象的“内容”是否都相等 8.2==和 equals 的区别 == 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址 equals 的话，它是属于 java.lang.Object 类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到 String 等类的 equals 方法是被重写过的，而且 String 类在日常开发中用的比较多，久而久之，形成了 equals 是比较值的错误观点。 具体要看自定义类里有没有重写 Object 的 equals 方法来判断。通常情况下，重写 equals 方法，会比较类中的相应属性是否都相等。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Override public boolean equals(Object obj) { if(this == obj){ return true; } if(obj instanceof Order){ Order order = (Order)obj; return this.orderId == order.orderId \u0026amp;\u0026amp; this.orderName.equals(order.orderName); } return false; } public class OrderTest { public static void main(String[] args) { Order order1 = new Order(1001,\u0026#34;orderAA\u0026#34;); Order order2 = new Order(1001,\u0026#34;orderAA\u0026#34;); System.out.println(order1.equals(order2)); } } 9.toString 开发中对于自定义的类在调用toString()时，也希望显示其对象的实体内容，而非地址值。这时候，就需要重写Object类中的toString().\n1 2 3 4 5 6 7 8 public class Person { private String name; private int age; @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age +\u0026#39;}\u0026#39;; } } 面向对象编程（高级） 1.关键字static 如果想让一个成员变量被类的所有实例所共享，这里的类变量、类方法，只需要使用 static 修饰即可。所以也称为静态变量、静态方法。\n1.2static 关键字 使用范围：\nstatic 用来修饰的结构：属性、方法; 代码块、内部类 被修饰后的成员具备以下特点：\n随着类的加载而加载 优先于对象存在 修饰的成员，被所有对象所共享 访问权限允许时，可不创建对象，直接被类调用 1.3静态变量 使用 static 修饰的成员变量就是静态变量（或类变量、类属性）\n1 2 3 4 5 [修饰符] class 类{ [其他修饰符] static 数据类型 变量名; } static String nation;//国籍 1.3.2 静态变量的特点 静态变量的默认值规则和实例变量一样。\n静态变量值是所有对象共享。\n静态变量在本类中，可以在任意方法、代码块、构造器中直接使用。\n如果权限修饰符允许，在其他类中可以通过“类名*.*静态变量”直接访问，也可以通过\n“对象*.*静态变量”的方式访问（但是更推荐使用类名.静态变量的方式）。\n静态变量的 get/set 方法也静态的，当局部变量与静态变量重名时，使用“类名.静态变量”进行区分。\n1.3.3内存分析 1.4静态方法 1.4.1语法格式 用 static 修饰的成员方法就是静态方法。\n1 2 3 4 5 [修饰符] class 类{ [其他修饰符] static 返回值类型 方法名(形参列表){ 方法体 } } 1.4.2 静态方法的特点 静态方法在本类的任意方法、代码块、构造器中都可以直接被调用。 只要权限修饰符允许，静态方法在其他类中可以通过“类名.静态方法“的方式调用。也可以通过”对象.静态方法“的方式调用（但是更推荐使用类名.静态方法的方式）。 在 static 方法内部只能访问类的 static 修饰的属性或方法，不能访问类的非 static 的结构。 静态方法可以被子类继承，但不能被子类重写。 静态方法的调用都只看编译时类型。 因为不需要实例就可以访问 static 方法，static修饰的方法内，不能使用this和super。如果有重名问题，使用“类名.”进行区别。 1 2 3 4 5 6 7 8 9 10 11 12 public class Father { public static void fun(){ System.out.println(\u0026#34;Father.fun\u0026#34;); } } package com.atguigu.keyword; public class Son extends Father{ // @Override //尝试重写静态方法，加上@Override 编译报错，去掉 Override不报错，但是也不是重写 public static void fun(){ System.out.println(\u0026#34;Son.fun\u0026#34;); } } 2.单例(Singleton)设计模式 ","date":"2024-08-09T02:39:19+08:00","permalink":"https://fcfco.github.io/p/java%E5%9F%BA%E7%A1%80/","title":"Java基础"},{"content":"","date":"2024-08-08T23:56:02+08:00","permalink":"https://fcfco.github.io/p/%E8%AF%84%E8%AE%BA%E6%B5%8B%E8%AF%95/","title":"评论测试"},{"content":"","date":"2024-08-08T21:22:30+08:00","permalink":"https://fcfco.github.io/p/newnewnew/","title":"Newnewnew"},{"content":"Hello Word! ","date":"2024-08-08T18:24:01+08:00","permalink":"https://fcfco.github.io/p/myfirstblog/","title":"MyFirstBlog"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://fcfco.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://fcfco.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://fcfco.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://fcfco.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://fcfco.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://fcfco.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://fcfco.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://fcfco.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://fcfco.github.io/p/emoji-support/","title":"Emoji Support"}]